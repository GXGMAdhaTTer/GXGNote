# Redis数据库

## 一、非关系型数据库基础

关系型数据库：MySQL，支持表结构

非关系型数据库：Redis，不是以表结构存储数据库

NoSQL，指的是**非关系型的数据库**。NoSQL有时也称作Not Only SQL的缩写

### 分类

基于键值对 key-value类型：**Redis**，memcached

列存储数据库 Column-oriented Graph：HBase

图形数据库 Graphs based：Neo4j

文档型数据库： MongoDB

MongoDB是一个基于分布式文件存储的数据库，主要用来处理大量的文档。

## 二、Redis(Remote Dictionary Service)

远程字典服务器

特点：开源的、C语言编写、高性能。可以用作**数据库、缓存、消息中间件**。基于**内存**的数据库、支持**持久化**（可以将数据长期保存）。

官网：https://redis.io/

### Redis三大特性

1. 支持持久化
2. 支持丰富数据类型
3. 支持数据备份（主从复制）

### Redis优点

1. 性能高 读11w/s，写8.1w/s
2. 丰富的数据类型（五大数据类型）
3. 原子：操作是原子的，但是Redis事务不支持原子
4. 丰富的特性 支持发布订阅、支持key过期

### Redis基本命令

```sql
#默认支持16个数据库
#数据库的切换  
select + 数据库的编号

#查看数据库的大小
 DBSIZE
 
#查看当前数据库key的多少
127.0.0.1:6379> keys *  #  *可以匹配0个到任意个字符  ？可以匹配一个字符
1) "k1"
2) "k2"

127.0.0.1:6379> keys k?
1) "k1"
2) "k2"
127.0.0.1:6379> 


#删除key值
127.0.0.1:6379> DEL k1
(integer) 1    #结果是1或者0
127.0.0.1:6379> keys *
1) "k2"
127.0.0.1:6379>

#情况数据库
127.0.0.1:6379> FLUSHDB  #清空当前数据库
OK
127.0.0.1:6379> 
127.0.0.1:6379> FLUSHALL  #清空所有数据库
OK
127.0.0.1:6379> 

#key值移动到其他数据库
127.0.0.1:6379> move k3 1
(integer) 1
127.0.0.1:6379>

#判断某个key值是不是存在的
127.0.0.1:6379> EXISTS k3
(integer) 0
127.0.0.1:6379> EXISTS k1
(integer) 1
127.0.0.1:6379>

#查看变量的类型
127.0.0.1:6379> type k1
string

#设置过期时间
127.0.0.1:6379> EXPIRE k1 20
(integer) 1

#查看过期时间
127.0.0.1:6379> ttl k1
(integer) 17   #-1表名永不过期  -2表示已经过期了
```

### Redis数据类型

| 类型                 | 简介                                                   | 特性                                                         | 场景                                                         |
| -------------------- | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| String(字符串)       | 二进制安全                                             | 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M | ---                                                          |
| Hash(字典)           | 键值对集合,即编程语言中的Map类型                       | 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) | 存储、读取、修改用户属性                                     |
| List(列表)           | 链表(双向链表)                                         | 增删快,提供了操作某一段元素的API                             | 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列          |
| Set(集合)            | 哈希表实现,元素不重复                                  | 1、添加、删除、查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 | 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 |
| Sorted Set(有序集合) | 将Set中的元素增加一个权重参数score,元素按score有序排列 | 数据插入集合时,已经进行天然排序                              | 1、排行榜 2、带权重的消息队列                                |

### 1. String

```
#设置命令
set  key value
set k1 100

#获取key值
get key


#同时设置与获取多个key
127.0.0.1:6379> mset k11 11 k12 12 k13 helloworld k14 12.3
OK
127.0.0.1:6379> mget k11 k12 k13 k14
1) "11"
2) "12"
3) "helloworld"
4) "12.3"
127.0.0.1:6379> 
127.0.0.1:6379> 

#获取子串
127.0.0.1:6379> GETRANGE k13 0 -1  #-1表示倒数第一个
"helloworld"
127.0.0.1:6379>

#设置子串
127.0.0.1:6379> SETRANGE k13 0 wu
(integer) 10
127.0.0.1:6379> GETRANGE k13 0 -1
"wulloworld"
127.0.0.1:6379>

#同时获取与设置
127.0.0.1:6379> getset k1 hello
"100"
127.0.0.1:6379> get k1
"hello"
127.0.0.1:6379> 

#给某个key设置过期时间，并且赋新值
127.0.0.1:6379> setex k1 20 3000  #ex expire
OK
127.0.0.1:6379>

#累加
incr #每次加1个

incrby key  + 值  #每次可以增加指定的值
```

### list数据类型

双向链表

```
#在链表的左右两边进行数据的插入与删除
lpush/rpush
lpop/rpop

#list的遍历
127.0.0.1:6379> lrange list1 0 -1
 1) "8"
 2) "6"
 3) "5"
 4) "4"
 5) "3"
 6) "2"
 7) "1"
 8) "20"
 9) "21"
10) "22"
127.0.0.1:6379>

#list是支持下标的（与STL中的list不一样,STL中的list不支持下标）
#lset  key  index value
127.0.0.1:6379> lset list1 0 888888  #下标的设置
OK

127.0.0.1:6379> lindex list1 8   #下标查找
"21"
127.0.0.1:6379>


#删除重复元素（与STL中list中unique不一样，unique需要进行sort）
127.0.0.1:6379> LREM list1 5 1
(integer) 5
127.0.0.1:6379> 


#修剪指定范围以外数据
127.0.0.1:6379> LTRIM list1 1 4
OK
127.0.0.1:6379>

#在指定元素的前后插入数据
127.0.0.1:6379> LINSERT list1 after 2 2222
(integer) 7
127.0.0.1:6379> lrange list1 0 -1
1) "5"
2) "4"
3) "100"
4) "3"
5) "200"
6) "2"
7) "2222"
127.0.0.1:6379> 


```

### set数据类型

```
#添加元素使用sadd
127.0.0.1:6379> sadd myset1 1 2 3 1 2 3 4 6 8
(integer) 6
#查看元素的个数
127.0.0.1:6379> scard myset1
(integer) 6
#遍历set
127.0.0.1:6379> smembers myset1
1) "1"
2) "2"
3) "3"
4) "4"
5) "6"
6) "8"
127.0.0.1:6379>
#随机获取number个数据
127.0.0.1:6379> srandmember myset1 3
1) "7"
2) "3"
3) "2"
127.0.0.1:6379> 
#随机选取num个元素并且删除
127.0.0.1:6379> spop myset1 1
1) "4"
127.0.0.1:6379> 
127.0.0.1:6379> 
127.0.0.1:6379> smembers myset1
1) "3"
2) "2"
3) "1"
4) "6"
5) "8"
127.0.0.1:6379>

#取差集、取交集、取并集
SDIFF key1 key2
SINTER key1 key2 
SUNION key1 key2
```



### sorted set数据类型

将每个元素的前面设置一个double分数（看成是权重）

```
127.0.0.1:6379> zadd myset2 10  k1  10 hello 10 world  10 wangdao
(integer) 4
127.0.0.1:6379> ZRANGEBYLEX myset2 - +   #此处-表示负无穷  +正无穷
1) "hello"
2) "k1"
3) "wangdao"
4) "world"
127.0.0.1:6379>
#保证元素的分数值一致的情况下面，使用ZRANGEBYLEX命令
#后面是范围值    [闭区间   (开区间
127.0.0.1:6379> ZRANGEBYLEX myset2 [h [k1
1) "hello"
2) "k1"
127.0.0.1:6379> 
```

### hash数据类型

Key-value模式不变，但value是一个键值对map<key, map<key1, value>>

```sql
#string类型可以看成是key-value类型，但是hash是key1-（key2-value）
#map<key, value>                 map<key1, map<key2, value>>
127.0.0.1:6379> set k1 100
OK
127.0.0.1:6379> hset hash1 str1 100
(integer) 1
127.0.0.1:6379> type k1
string
127.0.0.1:6379> type hash1
hash
127.0.0.1:6379> 

#一次可以获取或者设置多个值
127.0.0.1:6379> hmset people age 10 sex man 
OK
127.0.0.1:6379> hmget people age sex
1) "10"
2) "man"
127.0.0.1:6379> 

127.0.0.1:6379> hkeys people
1) "age"
2) "sex"
127.0.0.1:6379> 
127.0.0.1:6379> 
127.0.0.1:6379> hvals people
1) "10"
2) "man"
127.0.0.1:6379>
```

## 三、Redis配置文件

路径：/etc/redis 下面有一个6379.conf

### redis服务器的启动

```
redis-server /path/to/redis.conf，以守护进程的形式开启
redis-server 不带配置文件开启redis服务器，带图形界面
```

## 四、持久化

### 概念

将redis中的数据从内存保存的磁盘

### 分类

RDB：将数据保存到磁盘上面（定期的将redis的数据dump到磁盘上面）

AOF：将每次执行的写命令保存到硬盘（原理是将Redis的操作日志以追加的方式写入文件，类似于MySQL的binlog），主流的持久化方式\

### RDB

#### RDB的特点

RDB是Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。（/var/lib/redis/6379）

#### 触发快照的方式

1. **在指定的时间间隔内，执行指定次数的写操作**（时间time和次数times要都满足，不然无法触发快照）

2. 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令

3. 执行flushall 命令，清空数据库所有数据，意义不大

![image-20220615212032900](https://gogogxg.xyz/img/20220624-172428-826.png)

4. 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义不大。

![image-20220615212043294](Redis数据库.assets/image-20220615212043294.png)

> 测试：save  30  2，要保证在30s以内执行2次写操作；保证时间30s要到达，写次数2次也要满足。
> 可以将时间设置在后面30s，并且先执行一些save，再执行两次写操作。

![image-20220615212439546](https://gogogxg.xyz/img/20220624-172435-013.png)

#### 优点

1 适合大规模的数据恢复，与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

#### 缺点

1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。

2 备份时占用内存，因为Redis 在备份时会独立创建一个fork子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。



### AOF(Append Only File)持久化方式

AOF方式是将执行过的**写指令记录下来**，在数据恢复时按照**从前到后的顺序再将指令都执行一遍**

默认情况下，是每秒同步一次。最多会丢失1s的数据

```
appendfsync always		一直同步
appendfsync everysec	每秒同步一次
appendfsync no 			从不同步

#下一次的写操作之后文件大小的增幅要达到100%，并且文件大小要达到64M，才能触发重写
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```



#### 优点

对数据完整性与一致性更高，最多只会丢失1s的数据

#### 缺点

对于大量数据恢复的时候，执行的命令的时间比较长

### 总结

两种持久化方式一般都是同时开启的，既能保证数据的完整性和一致性，也能保证大量数据恢复的时候速度比较快

如果只开启aof持久化的方式，并且.aof文件损坏，此时redis不能启动成功

如果.aof文件损坏，可以使用`refis-check-aof --fix`修复（rdb也可以）

## Redis事务

#### 1、概念

一组命令的集合。



#### 2、三个阶段

开启事务、命令入队（命令之间不会有加塞）、执行事务



#### 3、事务的基本操作

```sql
#开启事务
multi

#执行事务
exec

#监视一个或多个变量
watch

#事务的基本操作
127.0.0.1:6379[2]> MULTI  #开启事务
OK
127.0.0.1:6379[2]> get k1   #执行第一条命令
QUEUED
127.0.0.1:6379[2]> get k2   #执行第二条命令
QUEUED
127.0.0.1:6379[2]> set k3 300   #执行第三条命令
QUEUED
127.0.0.1:6379[2]> exec  #执行事务
1) "100"
2) "hello"
3) OK
127.0.0.1:6379[2]> 
```

![image-20220614172650700](https://gogogxg.xyz/img/20220624-172444-025.png)



![image-20220614173051253](https://gogogxg.xyz/img/20220624-172455-089.png)

可以把这两种错误看成是编译起码时候的，编译时出错（set k5，语法不通）以及运行时出错（incr k2）

**总结：redis的每条命令是原子的，但是redis的事务是不保证原子性的。（MySQL事务是具有原子性的）**

**watch可以监视某个变量**

![image-20220615161226912](https://gogogxg.xyz/img/20220624-172501-611.png)



#### 4、事务的锁机制

悲观锁：每次拿数据的时候，都会对数据进行加锁操作。

乐观锁：每次去拿数据的时候都不会上锁（**使用版本号机制或CAS操作实现**）

原子数据类型_int



#### 5、事务的特征

1、单独的隔离操作 
2、没有隔离级别的说法
3、事务不保证原子性

## Redis主从复制

主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是**单向**的，只能由主节点到从节点。

**实现负载均衡、故障恢复、读写分离。** 

### 配置步骤

1、在/etc/redis下面，拷贝6379.conf到6380.conf与6381.conf，然后修改6380与6381中的数据

端口号port：6379  6380 6381
pidfile： pidfile "/var/run/redis_6380.pid"
日志文件：logfile "/var/log/redis_6380.log"
dump.rdb：dbfilename "dump6380.rdb"
aof文件名：appendfilename "appendonly6380.aof" 



2、分别启动三台redis服务器

sudo redis-server   /etc/redis/6379.conf
sudo redis-server   /etc/redis/6380.conf
sudo redis-server   /etc/redis/6381.conf

![image-20220615100006790](https://gogogxg.xyz/img/20220624-172513-347.png)



3、登录到对应的服务器的客户端

redis-cli -p 6381 
redis-cli -p 6380 
redis-cli -p 6379



4、在每个客户端下面执行info replication，查看主从复制的信息（默认情况下，每台机器都是主节点）

![image-20220615100411097](https://gogogxg.xyz/img/20220624-172517-111.png)

5、在设置为从机的客户端上面，执行相应的命令

SLAVEOF 127.0.0.1 6379



6、现象

- 在主机上面进行写操作，数据会备份到从机上面来，从机是不能进行写操作的。
- 当主机挂掉之后，从机会默默等待主机上线，从机之间不会自动竞争为主机身份。当主机6379重新恢复上线的时候，6380与6381会自动连接到6379上面，还是6379的从机。
- 将6381设置为6380的从机，结构上6379是6380的主机，6380是6381的主机，6380此时还是从机的身份。在6379上面写的数据会备份到6380，再从6380备份到6381。同时6380虽然是6381的主机，但是6380是6379的从机，所以6380上面仍然不能进行操作。
- 将从机挂掉之后，在重新上线，从机依然会连接到之前的主机上面。

## 哨兵模式

可以使用一个哨兵进行监视主机，当主机挂掉之后，会执行**流言协议**并且执行**投票协议**，让剩下的从机竞争出一个主机。

### 哨兵的配置

1、配置文件

```sql
sentinel monitor master6379 127.0.0.1 6379 1  #监视的主机6379
```

2、启动哨兵的配置文件

sudo redis-server /etc/redis/sentinel.conf

3、将主机6379挂掉（shutdown）

4、哨兵就会进行投票，选出新的主机



可以解决的问题：当主机挂掉之后，从机依然是从机，群龙无首的现象。



## Redis常见问题

### 缓存雪崩

一般热点数据都会去做缓存，一般缓存都是定时任务去刷新，定时刷新就有一个问题：

大量的数据在同一时间失效了，多个请求进行查找的时候，不能再缓存中找到，只能在底层的数据库中进行查找，此时数据库的压力很大。

解决方案：

1. 分散失效时间，让数据不再同一时间失效

2. 可以不设置过期时间

> 缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
> 解决方案：
>
> 1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
> 2. 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。

### 缓存击穿

某个热点key值在缓存中失效了，如果大量请求都进来的时候，在缓存中找不到该key，这些请求都会到底层数据库进行查找，底层数据库的压力就比较大。

解决方案：延长热点数据的过期时间或者让其永不失效。

> 专业回答：
>
> 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
> 解决方案：
> 1. 设置热点数据永远不过期。
> 2. 利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至Redis内，避免其他大量请求同时穿过Redis访问底层数据库。

### 缓存穿透

查找的数据在缓存以及底层数据库中，压根就不存在，每次查找都必须到底层数据库，底层数据库的压力也会非常大。

解决方案：`map<key, null>`

缓存空对象，可以设置一个key以及对应的value值为空，并且存放在缓存中，这样当进行查找的时候如果value为空，就不会继续在底层数据库上进行查找。

> 专业回答：
>
> 缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
>
> 1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
> 2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
> 3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

## Hiredis

安装hiredis，对应的安装步骤

```C++
tar -xzvf hiredis.tar.gz
cd hiredis
make
sudo make install

//更新缓存
sudo ldconfig
    
//相应的头文件
/usr/local/include
```

#### 使用

在代码中包含头文件即可

```C++
#include <hiredis/hiredis.h>
```

#### 编译

```c++
g++ *.cc -lhiredis
```

#### 四个API

```C++
//进行数据库的连接
redisContext* redisConnect(const char *ip, int port);

//对应命令的执行
void *redisCommand(redisContext *c, const char *format...);

//两个释放的命令
void freeReplyObject(void *reply);

void redisFree(redisContext *c);
```



## 面试题

1、 什么是Redis?有哪些有优缺点？

```
Remote Dictionary Service
远程字典服务器

特点：开源的、C语言编写、高性能。可以用作数据库、缓存、消息中间件。基于内存的数据库、支持持久化（可以将数据长期保存）。

三大特性
1. 支持持久化
2. 支持丰富数据类型
3. 支持数据备份（主从复制）

优点：
1. 性能高 读11w/s，写8.1w/s
2. 具有丰富数据类型（五大数据类型）
3. 原子的：操作是原子的，但是Redis事务是不支持原子的
4. 丰富的特性 支持发布订阅、支持key过期



Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。

优点：
与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。

缺点：
数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
```

2、为什么要用 Redis /为什么要用缓存

```
高性能、高并发

高性能：
加入用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中相应的数据即可。

高并发：
直接操作缓存能够承受的请求是远远大于直接访问呃数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。
```

3、 Redis为什么这么快

```
1. 完全基于内存，绝大，部分请求是存粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。

2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。

3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换和消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

4. 使用多路I/O服用模型，非阻塞IO。
```

4、Redis有哪些数据类型

| 类型                 | 简介                                                   | 特性                                                         | 场景                                                         |
| -------------------- | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| String(字符串)       | 二进制安全                                             | 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M | ---                                                          |
| Hash(字典)           | 键值对集合,即编程语言中的Map类型                       | 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) | 存储、读取、修改用户属性                                     |
| List(列表)           | 链表(双向链表)                                         | 增删快,提供了操作某一段元素的API                             | 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列          |
| Set(集合)            | 哈希表实现,元素不重复                                  | 1、添加、删除、查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 | 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 |
| Sorted Set(有序集合) | 将Set中的元素增加一个权重参数score,元素按score有序排列 | 数据插入集合时,已经进行天然排序                              | 1、排行榜 2、带权重的消息队列                                |

5、什么是Redis持久化？

```
持久化：把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。
```

6、Redis 的持久化机制是什么？各自的优缺点？

```
Redis提供两种持久化机制RDB(默认)和AOF机制。

RDB(Redis DataBase)
在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。（/var/lib/redis/6379）

触发快照的方式
1. 执行shutdown命令，会触发快照
2. 执行flushall命令，也会触发快照
3. 手动执行save命令，也会触发快照
4. 在指定的时间间隔内，执行指定次数的写操作（时间time和次数times要都满足，不然无法触发快照）

优点：
1. 只有一个文件 dump.rdb，方便持久化。
2. 容灾性好，一个文件可以保存到安全的磁盘。
3. 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能
4.相对于数据集大时，比 AOF 的启动效率更高。

缺点：
1. 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)
2. 备份时占用内存，因为Redis 在备份时会独立创建一个fork子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

AOF(Append Only File)
将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍。

appendfsync always		#一直同步
appendfsync everysec	#每秒同步一次
appendfsync no 			#从不同步

#下一次的写操作之后文件大小的增幅要达到100%，并且文件大小要达到64M，才能触发重写
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

优点：
1. 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。
2. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
3. AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)
缺点：
1. AOF 文件比 RDB 文件大，且恢复速度慢。
2. 数据集大的时候，比 rdb 启动效率低。

两者对比：
AOF文件比RDB更新频率高，优先使用AOF还原数据。
AOF比RDB更安全也更大
RDB性能比AOF好
如果两个都配了优先加载AOF

总结：
两种持久化方式一般都是同时开启的，既能保证数据的完整性和一致性，也能保证大量数据恢复的时候速度比较快
如果只开启aof持久化的方式，并且.aof文件损坏，此时redis不能启动成功
如果.aof文件损坏，可以使用`refis-check-aof --fix`修复（rdb也可以）
```

7、 Redis key的过期时间和永久有效分别怎么设置？

```
EXPIRE和PERSIST命令。

#设置过期时间
127.0.0.1:6379> EXPIRE k1 20
(integer) 1

我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?

除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：

1. 定时去清理过期的缓存；
2. 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。

两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。
```

8、Redis事务的概念

```
一组命令的集合。
Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。
总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。
```

9、Redis事务的三个阶段

```
MULTI	开启事务
		命令入队（命令之间不会有加塞）
EXEC	执行事务。
```

10、Redis事务相关命令和事务的特征？

```
Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的

Redis会将一个事务中的所有命令序列化，然后按顺序执行。

1. redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
2. 如果在一个事务中的命令出现错误，那么所有的命令都不会执行；
3. 如果在一个事务中出现运行错误，那么正确的命令会被执行。
- WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。
- MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
- EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。
- 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
- UNWATCH命令可以取消watch对所有key的监控。
```
